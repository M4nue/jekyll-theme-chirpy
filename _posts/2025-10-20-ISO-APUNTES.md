ÍNDICE

[**Definiciones4**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.b29921tmqgm9)

[**FICHEROS/DIRECTORIOS IMPORTANTES4**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.pebz7jv5ceiz)

[DIRECTORIOS RAÍCES4](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.13eh30yafgi9)

[**APUNTES PROPIOS7**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ykeqzqllk5bo)

[**ATAJOS DE TECLADO Y TRUCOS7**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.oa17u27368r)

[**COMANDOS8**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.61zs46gu3h2t)

[**VARIABLES12**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.dchvcytgmkfg)

[**Temario13**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ig1y7c5toiwr)

[Tema 113](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.79so4du6vs9l)

[PERMISOS14](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.pya5aaerzprq)

[TIPOS DE FICHEROS14](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.iz9kbf4h4s5x)

[EXPANSIÓN DE NOMBRES DE FICHERO14](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.fv73j1s6basm)

[EXPRESIONES DE NOMBRES COMPLEJAS15](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ud8jeym4z6g)

[EXPRESIONES LÓGICAS15](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.n5oo2awo8ylv)

[EXPANSIÓN DE COMANDOS16](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.be1qmb6evuet)

[CLAVES PÚBLICAS-PRIVADAS17](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.qnh6phiahdr1)

[CARACTERES DE PROTECCIÓN I17](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ppa6c2r4jjgp)

[COMILLAS SIMPLES18](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.w2jz71yqyyqm)

[CARACTER \\ SLASH18](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.jkk4nfuz3ycz)

[COMILLAS DOBLES18](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.o154d7z4edck)

[OPERADORES18](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.zfw927qfako6)

[OPERADOR “Y” LÓGICO: &&18](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.bw2n7qpwfgy)

[OPERADOR “O” LÓGICO19](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.igltwf26dpnq)

[OPERADOR “;” LÓGICO19](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.iafyd93qp9td)

[AGRUPACIÓN DE COMANDO19](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.7csjf4epqc4u)

[**GENERACIÓN DE MÚLTIPLES FICHEROS 119**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.3g5bf72l7u4j)

[**ALIAS20**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.xb6g6jara5gw)

[**ENLACES BLANDO / SOFT LINKS20**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.40qsjnp3m0mr)

[**ENLACES DUROS  / HARDLINK21**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ku0twr497zky)

[REDIRECCIONES21](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.z9ljfznhovca)

[Redirecciones simples22](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.cjt7mtffd9el)

[Redirecciones dobles22](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.6ob992xknyk9)

[Redirecciones de entradas simples22](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.mneqmvpxsqed)

[Redirecciones de entradas dobles22](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.l8y55fmzbupf)

[CANALES ESTÁNDARES23](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.2cocwt75a6lp)

[APERTURAS DE CANALES 3-924](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.fksrs5hbxbi3)

[TUBERÍAS O PIPELINES24](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.vx1dun350973)

[Tuberías Con Nombres25](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.srbo44cdcl4y)

[COMANDO TEE25](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.xvjjvia315ya)

[COMANDO XARGS26](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.8p1zekr87ucc)

[COMANDO FIND27](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.iptx4uadoorr)

[COMANDO LOCATE29](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.s3c5g6v1jdfe)

[GREP29](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.brb5wez65zk9)

[RENAME31](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.o7m6rp7fke8b)

[SED32](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ntserqgfgfcd)

[SED-ACCIÓN32](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.b9mz0nowhsoj)

[SED-DIRECCIÓN SIMPLE32](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.2hd53b1ujz83)

[SED-COMANDOS33](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.hmhaekwg9gko)

[d (delete)33](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.x9bb6s6sjrf6)

[p (print)33](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.dupc5yyijanc)

[\= (Mostrar)33](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.vfz0ea73ids)

[! (negación)33](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.87c4bi6c15cd)

[s (sustitución)33](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ixgtisshgx44)

[w (write)33](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.eyofqxhzn79q)

[a (anexar)34](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.j9841hadh8qw)

[i (insertar)34](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.tpesqx2hwse9)

[c (reemplazar)34](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.q6iy4x14pg9n)

[CUT35](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.1arzu3ceuvm3)

[TR35](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.fs74yqh4idjt)

[AWK35](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.815z2nmxf7mq)

[AWK, VARIABLES35](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.vxsrxkc6phci)

[AWK, ACCIÓN-AWK PRINT36](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ji3357mrkzde)

[SISTEMAS DE FICHEROS/ARCHIVOS37](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.q45rd9nv68kj)

[Supuesto practico137](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.r1yz3ll3fp9b)

[Supuesto practic o237](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.jc5az2lvyu6)

[HERRAMIENTAS SISTEMAS DE FICHEROS37](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.sxtjzkj24e7j)

[TABLA DE INODOS37](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.2zadandg4wjc)

[DIRECCIONES INDIRECCIONES DE INODOS38](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ni13hes6k3wm)

[dumpe2fs38](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.xahvvfz2bh7b)

[ext3grep38](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.myuhsosw4fms)

[CREACIÓN DE UN SISTEMA DE FICHEROS39](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.nda6h6am0559)

[**UEFI SHELL39**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.t77guhsedczk)

[**SWAP40**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.jc29md8mj0yw)

[**JOURNALCTL43**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.r4z4u75nhqkd)

[**GRUB EFI INITRAMFS43**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.7rm274p1tbiz)

[**PROCESOS43**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.b98a51mrp23d)

[**SESIONES45**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.aivcp11htl5g)

[**SCRIPT48**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.ji99tbh93pwq)

[PASO DE ARGUMENTOS AL SCRIPT49](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.lhnhdq5wz2l3)

[ENTRADA DE DATOS MANUALMENTE AL SCRIPT49](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.vxv8kywaki09)

[ESTRUCTURA CONDICIONAL IF51](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.re3g18sebu2x)

[Condiciones sobre cadenas de texto51](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.x8dbbacqx4jk)

[Condiciones sobre numericos51](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.flg4wikbwag9)

[Condiciones sobre ficheros51](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.8lw4hql3upgb)

[OPERADORES LÓGICOS52](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.7b4q1lt7u11g)

[AGRUPACIONES52](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.qrk35jdv0znm)

[COMANDO \[\[ \]\]52](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.hojihj4xxuvp)

[COMPARACIÓN DE CADENAS MEDIANTE PATRON53](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.jg0gixhumfvc)

[ESTRUCTURA IF54](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.d51kbnriauns)

[LIBRERAS54](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.78kx23o28078)

[getops55](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.lpmjy7tx67s3)

[BUCLES55](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.e69sj0e4z2t7)

[SENTENCIA CASE55](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.oq3dd1whhykh)

[Ficheros56](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.1mzipskb3eyk)

[DEPURACIÓN DE SCRIPTS56](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.fbz4uzbhz61y)

[**DIALOG57**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.9yb8j9frt6kg)

[**USUARIO ESPECIALES58**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.k0p8nx9mlwer)

[**WINDOWS59**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.tgccsrmtyiwn)

[bcdedit editor de configuración de arranque61](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.p06b6onz6uzp)

[POWERSHELL61](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.kyiy6jilevbb)

[**ACTIVE DIRECTORY62**](https://docs.google.com/document/d/103dERgqXOFZX2vz6ViybsobzfNhumvKypoLenwkZyKw/edit?tab=t.0#heading=h.itwmcms4okgg)

Definiciones
------------

*   **Sistema informático**: Conjunto de hardware y software
    
*   **Hardware**: Parte fisica del sistema informatico (Raton, pantalla…)
    
*   **Software:** Parte no física (Programas, aplicaciones…)
    
*   **Drivers o Controladores**: Software específico que comunica el hardware y el software
    
*   **Kernel**: Núcleo de los SO GNU/Linux
    
*   **Firmware**: Software básico que controla las funciones de los componentes electrónicos del equipo
    
*   **Máquina Virtual**: Emulación de SO
    
*   **Hipervisor**: Software que permite comunicar las MV con el hardware
    
*   **Contenedor** (_Docker / gubernetes_): Máquina virtual ligera, que solo emula una cosa para evitar utilizar una gran cantidad de recursos a diferencias de las MV
    
*   **Form**: Distribuciones basadas en una principal pero modificadas para estar especializadas en algunos temas concretos, por ejemplo:(Debian-Kali,Parrot)
    
*   **Fable**: Distribución como el form pero depende más del SO principal
    
*   **LTS**: Soporte a lago tiempo, para SO estables
    
*   **Caché**: Almacena datos que se van a utilizar más probablemente en el futuro, concediendo más velocidad
    
*   **Abastecimiento liviano LVM**: Almacenamiento dinámico, yo le especifico el tamaño y conforme lo vaya necesitando lo va cogiendo, no los reserva directamente del disco
    
*   **INITRAMFS**: Añadidos al arranque que contiene módulos para el kernel
    
*   **Frase de paso**: “Contraseña” para controlar el uso de mi clave privada, evitando que alguien que tenga mi sesión no pueda utilizarla solicitando la frase de paso para las conexiones, parecido a “sudo”, solicita la frase de paso cada x minutos
    

FICHEROS/DIRECTORIOS IMPORTANTES
--------------------------------

### DIRECTORIOS RAÍCES

*   /boot: Contiene todos los archivos esenciales para iniciar debian, cada vez con menos frecuencia el directorio se almacenan en una partición separada, por varios motivos
    
    *   La BIOS antigua no podía leer el sector más alla de cierto cilindro, no es el caso de EFI
        
    *   El cargador de arranque no entiende la partición / RAID /  de sistemas LVM utilizanco la partición / 
        

Dentro de el directorio encontraremos 4 archivos para cada versión de kernel que encontremos

*   **vmlinuz-”Vesion\_kernel”:** Binario actual del kernel
    
*   **initrd.img-”Version\_kernel”**: Pequeño sistema de archivos raiz temporal que solo se utiliza para el arranque del sistema. Toma el control desde el cargador de arranque (grub, lilo, etc…), carga controladores esenciales y realiza tareas esenciales para el arranque
    
*   **config-”Versión\_kernel”:** contiene opciones de configuración con las que se compiló el kernel (como referencia)
    
*   **system.map-”version\_kernel”:** Contiene nombre de simbolos y direcciones del binario del kernel de linux, su nico uso real es para depurar y no es esencial en el resto del tiempo
    

También podemos encontrar subdirectorios como grub, chos,emile, efi … estos varían en función del cargador de arranque que tengamos

*   /dev: Contiene los archivos especiales del dispositivo para todos los dispositivos, estos son creados durante la instalación y más tarde con el **/dev/MAKEDEV.** El /dev/MAKEDEV.local es un script escrito por el administrador del sistema que crea dispositivo solo local archivos o enlaces (es decir aquellos que no forman parte de la norma MAKEDEV), como los archivos de dispositivos para algunos controladores de dispositivos no estándar
    

*   /etc:Directorio que almacena subdirectorios o archivo relacionados con la configuración del sistema o servicios. Siempre que se instala una nueva aplicación, los archivos de configuración se conservan aquí por defecto
    

*   /bin: En debian como tal no es un directorio sino un enlace a **/usr/bin** que contiene ejecutables esenciales para la funcionalidad básica del sistema, los binarios almacenados en este directorio son utilizable por todos los usuarios, el administrador, root y el sistema
    

*   /sbin: Similar a **/bin** pero este contien binarios que solo el sistema, el administrador o root pueden utilizar, tambien es un enlace a **/usr/sbin**
    

*   /home:Alberga directorios específicos de los usuarios. Estos directorios son los directorios de trabajo de los usuarios del sistema que tienen permiso de login a excepción de root
    

*   /media:
    
*   /mnt:
    
*   /opt:
    
*   /proc:
    
*   /root:
    
*   /run:
    
*   /srv:
    
*   /sys:
    
*   /tmp:
    
*   /usr: Esencial para gestionar eficazmente los recursos del sistema, acceder a binarios y archivos específicos del usuario. Contienen archivos y directorios que no son necesarios para la funcionalidad básica del sistema sino que son esenciales para ejecutar software instalado y soportar operaciones específicas del usuario. Estos son algunos aspectos claves del directorio
    

*   Finalidad y estructura: Generado para mantener archivos y directorios no necesarios para arrancar el sistema. A menudo se monta como una partición separada para la flexibilidad en la gestión de los recursos del sistema. Cuenta con subdirectorios ordenados jerárquicamente específicos para cada función **/usr/bin** para los binarios de usuarios, **/usr/lib** para las bibliotecas compartidas, **/usr/share** para los datos compartido y **/usr/include** para los archivos de cabecera
    

*   Subdirectorios en /usr:
    
    *   /usr/share: Archivos de datos independientes de la arquitectura, como pueden ser documentación e iconos
        
    *   /usr/lib: Bibliotecas requeridas por el software instalado
        
    *   /usr/local: Se utiliza para software y archivos que son especificos de la máquina local, no estań gestionados por el gestor de paquetes de la distribución
        
    *   /usr/src: A menudo contiene el código fuente de los softwares instalados permitiendo a los usuarios examinarlos y modificarlo
        

Los administradores y usuarios pueden obtener una comprensión más profunda de la organización del sistema y localizar archivos o recursos específicos cuando sea necesario

*   /var: Almacena datos como artículos de noticias, correos electrónicos, sitios web, bases de datos, la caché del sistema de empaquetado.
    

Estos datos cambian cuando el sistema se ejecuta normalmente, son específicos para cada sistema por lo que no se puede compartir por red 

*   **/etc/sudoers:** Fichero de sudoers
    
*   **/etc/apt/sources.list:** Fichero con los repositorios
    
*   **/etc/motd:** Fichero para expresar comentarios para inicios de sesión por terminal
    
*   **/home/usuario/.ssh:** Se pueden alojar las claves públicas-privadas de conexiones ssh, puede no estar creado y debemos de crearlo manualmente
    
*   **/home/usuario/.ssh/known\_host:** Almacena los hash de las máquinas ssh al que se han conectado (después de confirmar el fingerprints), para saber qué máquinas son. 
    
*   **/var/cache/apt/archives/:** Directorios que almacena los archivos .deb descargados de los repositorios, estos archivos contienen todo lo necesario del paquete luego una vez obtenido el sistema se encarga de extraer su contenido y este paquete queda “inservible” 
    
*   **/etc/services**: Fichero informativo que muestra el servicio, el puerto que utiliza junto con el protocolo y una breve descripción de estos
    
*   **/usr/share/man:** Contiene directorios de los lenguajes disponibles del manual y los tipo de manuales disponibles
    
*   **/etc/ssh/ssh\_config:**Archivo de configuración de ssh con una serie de parámetros como si permitir el acceso por contraseña número de puertos túneles … 
    

APUNTES PROPIOS
===============

En el sistema podemos encontrar diferentes usuarios a demás de root y el usuario propio, estos usuarios pueden ser **avahi, raíz, syslog, messagebus, nadie, ntp, rtkit y whoopsie** a diferencia de los usuarios como root estos son demonios del sistemas y representan los procesos ejecutados por **init system** si miramos el archivo **/etc/passwd** podemos ver que estos usuarios estan incluidos pero al final de la linea de estos donde se define la shell de los usuarios estos solo poseen **/usr/sbin/nologin** o **/bin/false**

ATAJOS DE TECLADO Y TRUCOS
--------------------------

**REINICIO ORDENADOR == Ctrl + ALT + Imp pant +R+E+I+S+V**

**MODIFICAR GRUB PARA ABRIR CON TERMINAL EN ROOT:** Necesitamos estar en el menú de grub, y hay una opción de edición de grub normalmente pulsando la e EN ESTE MOMENTO TENEMOS TECLADO ANGLOSAJON.

Después buscar la linea del kernel que suele contener vmlinuz y en en ella se indica que el arranque es readonly (ro) y modificamos por rw init=/bin/bash

**INDICAR A GRUB QUE DETECTE OTROS SO**: editar el archivo /etc/default/grub y buscar una línea donde indique OS\_PROBE esta es la encargada de detectar los diferentes SO instalados y de añadirlos en el menú de arranque. Finalmente debemos de actualizar el grub

Concatenación de comandos: Se pueden concatenar comando en una unica linea “;” con ; se ejecuta el primer comando y luego el segundo con && se ejecuta el primer comando y si tiene exito el segundo 

Retroceder: En vez de realizar Ctrl + z desde la consola se debe de utilizar Ctrl + Shift + “-”

Crear un fichero de texto sin touch o herramientas similares utilizamos :> nombre.txt o simplemente con la > 

Ctrl + d indica la finalización de introducción de texto

Ctrl + x + e abre un editor de texto, el archivo está en memoria y desde la terminal de bash se guarda en el archivo, desde terminator no  

COMANDOS
--------

COMANDO \[ PARÁMETRO (- –) \] \[ARGUMENTOS\]

*   Uname: Muestra cierta información del SO como el kernel
    
*   help: Muestra los comandos internos o en combinación de otro comando, muestra su ayuda
    
*   Tasksel: Lista las interfaces gráficas disponibles a instalar, las task son las interfaces
    
*   whereis: Devuelve las PATH para saber donde se encuentra los binarios
    
*   History: Comando que te indica los comando utilizados, estos se almacenan en el .bash\_history
    
*   man: Muestra el manual de un comando o variable
    
*   useradd: Añade o crea un usuario
    
*   Type: Devuelve el tipo de comando (externo interno), funciona tambien con funciones indica que función es y muestra su código
    
*   apt show: Muestra información de un paquete que no está instalado 
    
*   echo: Imprime información con -e da formato al texto \\n intro \\t tabulación…
    
*   file: Indica el tipo de fichero
    
*   df -h: Muestra información sobre el sistema de ficheros
    
*   !!: Ejecuta el último comando ejecutado, Si queremos ver el comando que va a ejecutar !! pulsamos CTRL + ESQ + e
    
*   !numero\_comando: Ejecuta el comando x almacenado en el histórico, CTRL + ESQ + e para editarlo
    
*   less: Paginador, necesita un input que se lo podemos pasar a través de una tubería
    
*   tree: Lista contenido de forma de árbol
    
    *   \-p: Muestra los permisos
        
*   chmod: Modifica o asigna permisos a los directorios o ficheros
    
*   :> : Podemos crear ficheros vacios
    
*   \> : También crea ficheros vacios
    
*   mkdir: Crea directorios
    
    *   \-m 777 directorios: Creamos los directorios con permisos específicos
        
    *   \-p path/to/directory: Crea las carpetas necesarios para crear la ruta
        
*   cp fichero ruta destino
    
    *   \-i: pide confirmación
        
    *   \-r: Copiado recursivo de una carpeta y todos sus subniveles
        
    *   \-a: Igual que -r pero si conserva los permisos
        
    *   \-f: Fuerza la copia
        
    *   \-u –update: Copia el archivo sólo si el original es más reciente
        
    *   \-p: Preservar los permisos y fechas
        
*   mv: Mover y renombrar ficheros
    
    *   mv fich1 fich2 cambio de nombre
        
    *   mv fich1 /prueba/fich1 mover el fichero
        
    *   mv fich1 /prueba/fich2 cambio de nombre y mueve el fichero
        
    *   \-u
        
*   ssh: Permite la conexión remota por terminales 
    
    *   \-i: Permite utilizar la clave privada para conexiones con claves públicas-privadas
        
*   ssh-keygen: Genera un par de claves pública-privada de conexión ssh
    
*   ssh-copy-id: Copia la clave pública en el directorio ~/.ssh/ del servidor generando un archivo de authorized\_keys que almacena estas claves
    

*   ssh-copy-id: Puede copiar la clave pública o privada en el servidor
    

*   ssh usuario@IP ‘comando’: Ejecuta el comando en la máquina remota
    
*   ssh-agent: Sirve para que se recuerde la frase de paso de la clave privada en una subterminal, solicita la frase de paso una vez y la almacena en memoria hasta que se cierre la sesión
    
*   uptime: Devuelve el tiempo que tiene encendida la máquina
    
*   pstree: Muestra de forma arborescente los procesos
    
    *   \-sp ID\_proceso: Muestra el proceso y los subprocesos de este
        
*   ps -aux | grep nombre\_a\_buscar: Muestra los procesos filtrados con el grep y el ID de estos
    
*   du:
    
*   apt clean: Borra todo lo que se encuentre en el directorio /var/cache/apt/archives
    
*   wc: Sirve para contar
    
    *   \-l: cuenta las lineas
        
*   useradd: añade un usuario al sistema
    
    *   \-m: Crea el directorio /home/nombre\_usuario
        
    *   \-s /bin/bash: Asigna una terminal al usuario
        
*   userdel:Elimina un usuario
    
    *   \-r: Elimina los archivos del home
        
    *   \-f: Elimina los /home\_nombre\_usuario
        
*   alias: Muestra los alias de la sesión 
    
    *   alias nombre=’comando’ crea un nuevo alias
        
*   unalias nombre\_alias: Elimina el alias indicado
    
*   tty: Muestra la sesión de shell en la que te encuentras
    
*   wget: Descargar archivos de internet desde la linea de comandos
    
*   find: Buscar diversos archivos
    
    *   find donde\_empezar\_a\_bucar \[-inum inodo\] \[-ls\]
        
*   md5sum: Si parametros realiza la operación matemática para encriptar y te devuelve el hash  que tendrá si se encripta con los datos actuales
    

*   stat: Muestra información muy detallada de algún fichero como la creación, acceso, modificación, cambio
    
    *   Modificación: Cambios en el contenido
        
    *   Cambio: Modificación de permisos propietarios etc
        

\-f: En vez de mostrar la información del fichero muestra la informacion de filesystem en el que se almacena

*   tr: Actualiza el contenido de un input que le indiquemos entre comillas por la sustitución. Solo se actualiza la salida por pantalla no el contenido del fichero
    
    *   tr ‘ ’ ’\\t’
        
*   time: time comando time cuenta cuanto tarda en ejecutar el segundo comando
    
*   cd: Permite moverse entre directorios
    
    *   cd - :Si ponemos solamente - sin ninguna letra o letras nos dirigimos al directorio anterior en el que estábamos
        
    *   cd: Si no ponemos argumentos nos vamos al $HOME 
        
*   mkfifo: Crea tuberías con nombres **mkfifo nombre\_tubería**
    
*   tee: Clona 2 canales pudiendo enviar los flujos de información a 2 sitios normalmente uno por pantalla y otro a un fichero
    
    *   \-a: Anexa y no sobreescribe
        
*   **:** Este comando no hace nada pero siempre retorna un código 0 equivalente a un TRUE
    
*   nmtui: Network manager terminal, proporciona una interfaz parecida a las de aptitude para controlar el gestor de red como en la interfaz gráfica
    
*   apt-cache show paquete: Muestra información del paquete
    
*   sort: Permite ordenar resultados por un criterio como puede ser alfanumérico
    
*   uniq: Muestra una única coincidencia
    
*   efibootmgr (efi boot management): Muestra las entradas de arranque de la efi, y realiza modificaciones de esta. En windows se conoce como bcdedit (boot configuration disk edit)
    
*   wipefs: Borrar filesystem
    
    *   \-af: Fuerza todo el borrado
        
*   stress: Estresar la swap
    
    *   \-m: Numero de trabajos
        
    *   –vm-bytes 256M: Unidad de bytes utilizados por los trabajos
        
*   pidof X: Muestra los PID de los procesos con X nombre 
    
    *   pidof -o 111 sshd: Muestra todos los PID de los procesos de sshd menos el 111
        
*   nohup:
    

VARIABLES
---------

Para definir variables se utiliza nombre\_variable=valor\_variable creamos una variable en memoria si queremos definirla permanentemente podemos añadirla en .bashrc o en un fichero que se ejecute en arranque

cadena=”este texto es el valor”

entero=10

Las variables pueden contener el resultado de la ejecución de un comando 

variable=$(comando)

Para ver que hace cada variable, estas se encuentran en el manual de bash man bash

*   $?: Almacena el código de ejecución del último comando ejecutado: echo $? ▶️ 0 ejecución exitosa, otro código es error
    
*   $\_: Indica el argumento del último comando ejecutado:
    
    *   ls /etc/sshd
        
    *   cd $\_ = cd /etc/sshd
        
*   $HISTSIZE: Tamaño que puede almacenar el histórico
    
*   $PPID: Sirve para ver el id padre
    
*   $BASHPID: Muestra el ID de la terminal
    
*   $$ : Muestra el PID de la bash actual
    

Temario
-------

### Tema 1

**SOFTWARE LIBRE**

Un software libre es aquel que cumple con una de las siguientes licencias libres evitando el copyright:

*   Usar: Poder usarlo con cualquier propósito (Libertad 0)
    
*   Aprender y Adaptar: Poder ver y modificar el código (Libertad 1)
    
*   Redistribuir: Poder crear copias y distribuirlas (Libertad 2)
    
*   Publicar Mejoras: Publicar los cambios del código para que la comunidad aprenda (Libertad 3)
    

Hay varios tipos de distribuciones:

*   Independientes: Debian, Rethat, Slackware.
    
*   Dependientes: Distribuciones dependientes o basadas en las independientes
    
*   Comunidad: Son base de las empresariales y creadas por usuarios de la comunidad: Fedora, OpenSUSE, RedHat
    
*   Empresarial: Utilizadas principalmente en el entorno empresarial: Red Hat, Suse, Canonical
    

Las empresas que utilizan un SO empresarial soportan económicamente a los desarrolladores de la comunidad para que sigan con los SO de la comunidad, estos cambios son adaptados e implementados en los SO empresariales  y estas sacan beneficio con el soporte técnico

Comandos Internos: Comando que ya viene instalado en la shell

Comandos Externos: Comando que no viene con la shell por lo que hay que instalarlo

REPOSITORIOS DEBIAN

Contrib: Paquetes casi libres, que en algun fichero o dependencia cuenta con una licencia no libre

Main: Paquetes completamente libres

Non-free: Paquetes no libres

Non-Free-Firmware: Drivers/modulos no libres

DISTRIBUCIONES DE DEBIAN

old old stable: Penúltima versión estables de debian buster

oldstable: Antigua versión estable de debian, bullseye

stable: Versión estable actual de debian, bookworm

testing: Versión futura todavía no estable de debian, trixie

unstable: Versión de desarrolladores para probar paquetes y demás, SID

experimenta: Mucho más inestable que unstable,

COMANDO \[PARÁMETROS\] \[ARGUMENTOS\]

PARÁMETROS: Opciones del comando, Definen como queremos el comando

ARGUMENTOS: Los valores en los que un comando deben realizar una acción

Los comando internos se ejecutan más rápidos que los externos y estos tienen preferencia en caso de haber uno externo e interno con el mismo nombre

#### PERMISOS

ugousuarios grupo otros

rwxrwxrwxread write execution

#### TIPOS DE FICHEROS

Cuando realizamos un **ls -al** la primera letra indica el tipo de fichero que es

\-: Ficheros ordinarios

d: Directorios

p: Tuberias con nombres

l: Links tanto softlinks o hardlinks

#### EXPANSIÓN DE NOMBRES DE FICHERO

Se utiliza para la creación 

(COMODINES) Expresiones básicas

Son caracteres de sustitución

\*: Representa Uno varios o ningún carácter, cualquiera

?: Representa a un carácter alfanumérico

\[ABC\]: Representa un carácter de los que hay dentro de los \[\], se sitúan todos juntos sin espacios

\[A-Z\] Representa un carácter dentro de un rango se describe el rango con \[\] letra o número guion y otra letra o número

\[^A-G\] Representa un carácter fuera del rango que se indica

\[!A-G\] Representa un carácter fuera del rango que se especifica 

{A,B,C} Representa los 3 caracteres se suele combinar con un prefijo para realizar un eje cartesiano 

{a..c}: Representa un rango similar a \[a-c\]

{A..Z..2} Representa un rango pero el incremento es de 2 en 2

Comodines: Pueden ser utilizado dentro de todos los argumentos que representen ficheros o ruta

\\: Permite cerrar un carácter especial, evitando que se tome como tal: \\\* hace que el comodín sea como una letra normal como la A

#### EXPRESIONES DE NOMBRES COMPLEJAS

Funcionan una vez los ficheros están creados

?(Expresión): La expresión estará presente 0 o 1 vez

\*(Expresión): La expresión estará presente 0 o n veces

+(Expresión): La expresión estará presente 1 o n veces

@(Expresión): La expresión estará presente 1 vez

!(Expresión): La expresión no estaŕa presente

#### EXPRESIONES LÓGICAS

| PAI, Dependiendo del contexto puede ser una tubería para enlazar comandos y las salidas de estos o como una expresión lógica que simula el OR

?(Expresión | Expresión): Una de las expresiones estará presente 0 o 1 vez

\*(Expresión | Expresión): Una de las expresiones estará presente 0 o n veces

+(Expresión | Expresión): Una de las expresiones estará presente 1 o n veces

@(Expresión | Expresión): Una de las expresiones estará presente 1 vez

!(Expresión | Expresión): Una de las expresiones no estaŕa presente

#### EXPANSIÓN DE COMANDOS

#### CLAVES PÚBLICAS-PRIVADAS

Al generar 2 claves una pública y otra privada ambas están relacionadas, las públicas la pueden ver todo el mundo y contrastar todos los usuario con sus claves públicas, estas se alojan en máquinas que necesiten accesos como servidores suelen tener .pub

Las claves privadas no tienen extensión suelen aparecer con permisos 600 aconsejable cambiarlos a 400 y está hace contraste con la pública alojada en los servidores, no modificar este archivo ya que la clave dejaría de ser útil

En este archivo se almacenan las claves públicas alojadas en el servidor 

Para conectarse con la clave privadas se utiliza ssh -i nombre\_clave usuario@IP

Necesario el paquete openssh-server en el servidor y openssh-client en la máquina cliente

#### CARACTERES DE PROTECCIÓN I

Tabulación, salto línea, espacio

Caracteres de separación

##### COMILLAS SIMPLES

Eliminan el significado de todos los caracteres especiales, tomando lo de entre comillas como un literal

echo $HOSTNAME ▶️ debian

echo ‘$HOSTNAME’ ▶️ $HOSTNAME

echo ‘Mi equipo se llama ‘$HOME’ >

echo ‘Comillas simples “protegen” a las comillas dobles ▶️ Comillas simples “protegen” a las comillas dobles

echo ‘El valor de \\$PWD es $PWD’ ▶️ El valor de \\$PWD es $PWD

##### CARACTER \\ SLASH

La barra invertida elimina el significado especial del carácter que le sigel

echo Ficheros del directorio actual: \* ▶️ El carácter \* sigue teniendo el significado del caracter

echo Ficheros del directorio actual: \\\* ▶️ Eliminar el significado del carácter

echo La varra invertida \\\\ protege a la segunda \\ ▶️ La barra invertida \\ protege

##### COMILLAS DOBLES

Elimina todos los sentidos especiales de todos los caracteres siendo literales menos de los caracteres **$ ‘’ $() \\**

echo “Well, ins´t that \\”special\\”” ▶️ Well, ins´t that “special”?

echo “Tienes ‘ls | wc -l’ ficheros en ‘pwd’” ▶️ Tienes 156 ficheros en /dev

echo “Tienes $(ls | wc -l) ficheros en $(pwd)” ▶️ Tienes 156 ficheros en /dev

echo “El valor de \\$PWD es: $PWD” ▶️ El valor de $PWD es: /dev

### OPERADORES

#### OPERADOR “Y” LÓGICO: &&

comando1 **&&** comando2

Concatena comandos, es decir ejecuta comando1 si se ejecuta correctamente y no da errores devuelve un código 0 de ejecución exitosa por lo que después ejecuta el comando2, en caso de que el comando1 de algún error devolverá otro código distinto de 0 por lo que no se ejecutará el comando2

EJ:

**cd Descargas && ls -l**

Si nos dirigimos a Descargas después listará el contenido de este con ls -l en caso de no poder acceder a la ruta descargas no ejecutara ls -l  

#### OPERADOR “O” LÓGICO

comando1 || comando2

Ejecuta el comando 1 o el comando2 en caso de que comando1 de un codigo diferente de 0 ejecuta el comando2

#### OPERADOR “;” LÓGICO

Similar al operador logico && pero este ejecuta todos los comando independientemente del código que devuelva

comando1; comando2; comando3

### AGRUPACIÓN DE COMANDO

Puedo agrupar comandos, estos al estar agrupados van a devolver un único codigo de ejecución en vez de uno a uno. Se pueden ejecutar

*   Los paréntesis(): Se ejecuta en una subshell (shell hijo), esta shell no cuenta con las variables o alias creados manualmente, es una shell “por defecto”
    
*   Las llaves{}: Se ejecuta en la shell actual
    

**pstree -sp PID** Muestra los procesos padres del proceso indicado

{ pwd ; ls ;} > /tmp/salida.txt

GENERACIÓN DE MÚLTIPLES FICHEROS 1
----------------------------------

Bucle for 

for variable {rango}; do comando;done

for i {0..9};do ‘touch fich$i.txt’;done

Este bucle crea ficheros del 0..9

Bucle for anidados

for i in {A..Z};

do for j in {0..9};

do $(touch fich$i$j.txt);

done;

done;

Podemos abrir un editor de texto en memoria pulsando Ctrl + x + e y crear el bucle con una estructura, este archivo se ejecuta inmediatamente al salir del editor

ALIAS
-----

Comando interno para poner nombre a comandos, pensado para poner nombre a comando muy largo o complejo o el cual vamos a utilizar much

alias nombre=’comando’

Si ponemos un alias con el nombre de un comando del sistema el sistema siempre ejecutará el alias, si alguna vez quiero ejecutar el comando en vez del alias debemos de escapar

\\alias y esto ejecuta el comando en vez del alias

AGRUPACIÓN DE ALIAS

se pueden crear varios alias a la vez

**alias \\**

**nombre=”comando” \\**

**nombre=”comando”**

ENLACES BLANDO / SOFT LINKS
---------------------------

Los enlaces blandos son fichero especiales que contienen la información de una ruta indicada, permisos y propiedades de la ruta.

ln -s ruta\_a\_la\_que\_apunta nombre

Un softlink se comporta a lo que apunta, si elimino un softlink no borro el directorio al que apunta y viceversa

Pueden apuntar a directorios y a otros ficheros de otros sistemas de ficheros, es decir con un softlink puedo tener enlaces a un sistemas de archivos diferentes como puede ser una unidad usb, esta es externa a la de mi equipo pero puede utilizar perfectamente un softlink apuntado a este, cuando este se retire el softlink quedará roto ya que no existe la ruta a la que apunta y quedará apuntando a la nada

Los enlaces simbólicos por defecto aparecen con permisos 777 pero verdaderamente se aplican los permisos que tengan el directorio o fichero al que apunta 

ENLACES DUROS  / HARDLINK
-------------------------

Asocia 2 o más ficheros teniendo el mismo inodo, estos enlace son una copia exacta del fichero al que apunta, mismo inodo. Si se cambia la ubicación del archivo original, el enlace no se rompe.

ln ruta\_a\_la\_que\_apunta nombre

No se pueden hacer hardlink a carpetas o diferentes sistemas de fichero particiones o discos.

Podríamos comprimir o empaquetar la carpeta y después hacer un hardlink a este archivo

Al sobrescribir un fichero se actualizan todos, por lo que hay peligro de sobreescritura al realizar :> hard1 en este caso deja bacio el archivo original y todos los hardlinks

REDIRECCIONES
-------------

Son desvíos de flujos de información de un canal con x salida a otro con y salida. La ejecución de comandos devuelven flujos de información con salida por pantalla.

Las redirecciones se utilizan normalmente con los comandos, permiten recuperar el resultado de uno o varios comando y enviarlo a un archivo o provocar la lectura de un archivo por un comando.

Todos los comandos cuenta con 3 descriptores o canales

*   Entrada estándar o descriptor 0 **stdin**
    

**Los procesos que esperan la entrada de información por parte** del usuario por la entrada estándar desencade una solicitud de lectura en el descriptor 0

*   Salida estándar o descriptor 1 stdout
    

Los procesos que necesitan enviar un mensaje al usuario como resultado de la ejecución de un comando tiene que acercar mediante el descriptor 1, está asociado por defecto a la pantalla

*   Salida de error estándar o descriptor 2
    

Los procesos necesitan enviar un mensaje de error al usuario como resultado de la ejecución de un comando tiene que hacerlo mediante el descriptor 2, tambien está asociado a la pantalla por defecto

### Redirecciones simples

Comando fichero

ls -l >listado.txtó ls -l 1>listado

Si no existe listado.txt se creará, lo primero que hace la shell es crear el fichero y despues la salida de la ejecución de comando la introduce este

ENTRADA0

1 stdaut PANTALLA

2 stderror PANTALLA

### Redirecciones dobles

En vez de sobreescribir ficheros, anexa la información al final de este

ls -l >> listado.txtóls -l 1>> listado.txt

Añadimos los datos de ls -l a listado.txt sin sobre escribir el contenido

### Redirecciones de entradas simples

Los comandos que esperan datos o parámetros pueden tambien recibirlos desde un fichero usando <

cat  < fichero.txt

wc < fichero.txtó wc 0< ficher.txt

Las redirecciones no funcionan con todos los comandos, debido a que no todos los comandos son iguales, hay comandos que aceptan entrada de datos otros que solo aceptan la salida de datos y otros ambas tanto salida como entrada de datos

### Redirecciones de entradas dobles

HereScript O Here Document, permite la insserción de un texto hasta un punto especificado y el envio de su resultado a un comando o un filtro

tr ‘ ‘ ‘\\t’ <

Ahora introducimos un texto. Al terminar de introducirlo pondremos de nuevo la etiqueta END y el texto se pasará al comando tr

Prioridades

Las redirecciones tienen prioridades unas con otras siendo el orden de más a menos el siguiente **<,>,>>**

Las redirecciones se representan de derecha a izquierda y se crea antes la estructura de redirecciones antes que la ejecución de comandos

*   Mirar la cantidad de redirecciones
    
*   Mirar el tipo de prioridad
    
*   En caso de ser iguales de derecha a izquierda
    

CANALES ESTÁNDARES
------------------

**ls z\*y\* > resultado.log 2>&1**

&1=Pantalla

primero indica que los errores los va a redireccionar por pantalla, despues indica que el resultado se envie al fichero, la shell comprueba que este fichero exista, sino lo crea y despues procede con la ejecución del comando, en caso de error lo envía por pantalla pero esta a su vez está reenviada al fichero y en caso de no error directamente se envía al fichero

stdin=ls0

1 stdout ➡️ resultado.log

stderr⤴️2 

**ls z\*y\* 2> resultado.log 1>&2**

En este otro caso es similar al caso de arriba pero esta vez los aciertos son enviados al canal stderr y este está redireccionado a resultado.log

**time find / > resultado.log**

En este caso los aciertos del comando find son enviados al resultado.log y los errores a la salida por defecto que es la entrada, el comando time va a contar el tiempo de ejecución del comando find desde principio hasta final

*   Errores en pantalla
    
*   wc -l < resultado.log
    
*   wc -l 0< resultado.log
    

time find / 1> resultado.log 2>&1

*   Todo a resultado.log
    

wc < fichero.txt > resultado.txt

*    El contenido de fichero es pasado a wc
    
*   El resultado e wc al fichero
    

ls t\* y\* 2>/dev/null

*   Los errores son enviados a /dev/null evitando que aparezcan por pantalla o se almacenen en otros ficheros
    

ls -l >/dev/null 2>&1

*   Los errores son reenviados a la pantalla y la pantalla al /dev/null y los aciertos directamente a /dev/null
    

COMO SABER SI UN COMANDO LLE DE SU ENTRADA STANDAR

*   Buscando en el manual del comando
    
    *   Ver si el argumento file aparece como opcional \[file\]
        
    *   If no file operands are specified, the standard input will be used
        
*   Probando el comando sin dar ningun nombre de archivo como argumento. El comando trar a los datos que lleguen por la entrada estandar. Se finalizará la introducción por entrada estándar, tecleado mediante intro y CRTL + d
    
*   Ejemplo, comando wc,cat,grep,sort…
    

APERTURAS DE CANALES 3-9
------------------------

### TUBERÍAS O PIPELINES

comando1 | comando2

La salida estándar del primer comando es pasado como entrada de datos del segundo

Permiten redireccionar el canal de salida de un comando hacia el canal de entrada de otro comando

Se pueden concatenar múltiples tuberías en la línea de comandos

**ifconfig eth0 | grep 192.168.1.100 n| wc -l**

### Tuberías Con Nombres

*   Las tuberías anteriormente vistas, se crean, se utilizan y se descartan una vez sse destruyen al ejecutar los comandos
    
*   Las tuberías con nombre son elementos persistente en el sistema de archivos (ficheros)
    
*   Son utilizadas en la comunicación entre procesos para enviar y recibir datos
    
*   Los datos permanecerán en la tubería hasta que sean leídos
    
*   Poner algo en una tubería con nombre es poner contenido en un extremo de la tubería, el otro extremo de la tubería solo se abrirá cuando…
    

Para crear una tuberia con nombre se utiliza el comando **mkfifo**

**mkfifo nombre\_tubería**

ls -al  

**p**rw-r–r– **nombre\_tuberia**

**\*\*\*No se pueden conectar procesos de una máquina con otra a traves de tuberias, solo se pueden utilizar con procesos locales, en caso de querer conectar los procesos de 2 maquinas utilizaremos sockets\*\*\***

### COMANDO TEE

Duplica la salida del canal estandar, redirecciona a varios sitos a la vez como a la pantalla y a un fichero

**tee \[-a\] fichero**

stdin->Tee->pantalla

||

ficheros

Tee solo redirecciona los aciertos, si queremos que tambien redireccione los errores necesitamos indicarselos a mano

**ls -l x\* y\* 2>&1 | tee fichero.txt**

*   Primero mira los redirectores
    
*   Monta la redirección por pantalla
    
*   Ejecuta el primer comando con las redirecciones por pantalla
    
*   La salida del comando es enviada a Tee a traves de una tuberia
    
*   Tee reenvia la información a pantalla y al fichero
    

Esto se utiliza para ver la información tanto de errores como aciertos por pantalla y almacenarla en un fichero

### COMANDO XARGS

Utilidad de linea de comandos que lee datos de la entrada estándar y los convierte en argumentos para otros comandos

**comando1 | xargs comando2**

El comando1 proporciona los argumentos a comando2

Vamos a generar un fichero y merter información y enviarselo a xargs  vemos que por defecto actua como un echo

con el parametro -n numero\_delimitador podemos modificar el formato de impresión indicando cada cuantos delimitadores de campo queremos crear otra línea

*   **\-I {}:** Especifica el valor pasado como argumento y lo reemplaza en {} al comando utilizado por xargs
    
    *   ls | xargs -l {} md5sum {} 
        

En este caso ls lista los archivos y estos son pasados a xargs en la posición de las {} después de eso xargs irá uno a uno con los archivos de ls y pasandolos a md5 en las posición de las {}

*   \-d Se indica los delimitadores de campo por defecto son espacios pero como puede ser el fichero /etc/passwd este no cuenta con espacios y los delimitadores de campo son : por lo que con esta opción se lo podemos indicar **\-d “:”**
    

*   \-t: Indica que es lo que está haciendo con cada argumento, xargs actúa como un echo pues indica echo argumento y salida de ese echo
    

*   \-0: Indica que los nombres de ficheros con espacios no son delimitadores de campo sino parte del nombre
    
*   \-P: Ejecución de procesos en paralelo
    

xargs cuenta con un buffer donde es capaz de almacenar muchos argumentos mayor que los buffer comunes de los comandos

xargs se suele utilizar con el comando find

**echo -e “acl\\nscreen\\ntree”**

COMANDO FIND
------------

Permite buscar ficheros mediante criterios

**find ruta criterios opciones\_visualización**

Find tiene relación con el comando **xargs** find es recursivo, es decir desde la ruta indicada hacia abajo.

Find conforme va buscando y encontrando las coincidencias va devolviendo el resultado y despues sigue buscando

*   \-name: Selección por nombres de ficheros, los criterios de busqueda deben ir entre comillas dobles. Acepta expansión de nombres de ficheros
    
    *   \-iname: No distingue entre mayusculas y minusculas
        
*   \-type: Selección por tipo de fichero
    
    *   b: Fichero de bloque
        
    *   c: ficheros tipo carácter
        
    *   d: directorios
        
    *   f: ordinarios
        
    *   l: ficheros tipo simbolico
        
    *   p: tuberias con nombre
        
    *   s: socket de conexión a red
        
*   \-user, -group: Busqueda por el propietario o UID. por grupo de pertenencia del propietario o GUID
    
    *   find . -name “p\*” -type d -user 1000
        
    *   find . -type f -user rafa
        
*   \-size: Indica el tamaño de los ficheros buscados, por defecto se emplea como unidad de bloque, 512Bytes
    
    *   b: Bloque 512Bytes
        
    *   c: Caracter ASCII, 1byte
        
    *   w: Una palabra, 2bytes
        
    *   k: kilobyte, 1024 Bytes
        
    *   \+ ó -: Los que sea más o menos del tamaño indicado o incluso los que sean mayores a **x** y menores de **y** tamaño
        
        *   \-size 100c 
            
        *   \-size 100k
            
        *   \-size +5K
            
        *   \-size -10k
            
        *   \-size 0 (ficheros vacios)
            
        *   \-empty
            
        *   \-size +10M -size -20M (busca ficheros de más de 10M y menos de 20M)
            
*   \-atime: Fecha de ultimo acceso (access time), puede ser la ultima lectura como último listado ls
    
*   \-mtime: fecha de ultima modificación (modification time)
    
*   \-ctime:(change time), ficha de última modificación del numero de inodo, modificación de nombre, cambio de derechos, tamaño etc.
    

atime, mtime, ctinme trabajan con días (n\*24)

*   +n: Busca valores mayor que n
    
*   \-n: Busca valores menores que n
    
*   n: Busca valores exactamente a n
    
*   0: significará el mismo día
    
*   1: significará ayer, entre 24 y 48 horas
    
*   2: sifnificará antes de ayer, etc
    
    *   \-mtime +30 -mtime -90 (busqueda entre 30 y 90 días)
        
    *   \-mmin +120 (busquedas mayores a 120 minutos)
        

*   \-newer
    
*   \-anewer
    
*   aaaaaa
    

*   \-perm: Permite la busqueda por permisos (derechos,SUID,SGID,STICKY BIT). Los permisos se precisoan en octal o en forma simbolica
    
    *   find . -perm -220
        
    *   find . -perm 664(La diferencia de los guiones es por compatibilidad de diferentes versiones de find)
        

Podemos buscar ficheros con operadores

*   AND, OR, 
    

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

*   \-exec: Ejecuta el comando colocado a continuación con cada una de las coincidencias que encuanete
    
    *   find . type f -name “\*.jpg” -exe rm -f {} \\;
        
    *   El comando asociado a -exec deberá terminar siempre con \\; \\escapa a ; (OBLIGATORIO, PARTE DE LA SINTAXIS DE -exec)
        
    *   Sustitución de fichero encontrado pro find con {} delimitados por los argumentos pasados al comando (parecido o similar a xargs)
        

¿Qúe opción es más rápida?

find . -type f -name “\*.jpg” -exec rm -rf {} \\;

find . -type f -name “\*.jpg” | xargs -l {} rm -rf

time find . -type f -name “\*.jpg” -exec rm -rf {} \\;

time find . -type f -name “\*.jpg” | xargs -l {} rm -rf

COMANDO LOCATE
--------------

Busca por nombre en una base de datos

*   updatedb: Actualizar la base de datos
    

**locate nombre\_fichero**

*   \-c muestra el número de resultados
    
*   \-i no distingue entre mayúsculas y minúsculas
    
*   –regex: Busca por expresión regular
    

GREP
----

Sirve para filtrar por expresiones regulares

*   grep: Utiliza expresiones regulares básicas para las búsquedas
    
    *   \-e: Similar a egrep
        
    *   \-F: Similar a fgrep 
        
    *   \-r: Similar a rgrep
        
*   egrep: Utiliza expresiones regulares extendidas para las búsquedas
    
*   fgrep:Obsoletos
    
*   rgrep:Oboletos
    

Su nombre deriva de un comando de texto ed que ten la siguiente forma g/re/p y significa hacer una búsqueda global para las líneas que encajen con la expresión regular

**grep \[-opciones\] Basic.expresion \[ficheros\]**

**grep -E \[Opciones\] Exten.expresion \[ficheros\]**

**Comando | grep \[-opciones\] Basic.expresion**

**grep \[-opciones\] Basic.expresion < Fichero**

Para comprender mejor cómo funcionan las expresiones regulares, se recomiendo la opción **–color=auto** que muestra la coincidencia en rojo

En el fichero **.bashrc** se cargan los siguiente alias comentados

**#alias grep = grep –color=auto**

EXPRESIONES REGULARES BÁSICAS Y EXTENDIDAS

\\

Escapa el siguiente carácter

^

Comienzo de línea

$

Final de línea

.

Un caracter cualqueira

\[lista de caracteres\]

Un caracter de los indicados en la lista

\[^Lista de caracteres\]

Un carácter de los no indicados en la lista

\*

Ningún, uno o varias veces  del carácter o grupo anterior. Igual a {0,}

\\<

Inicio de palabra. Los caracteres válidos son: **a-zA-Z0-9**

\\>

Final de palabra. Los caracteres válido son: **a-zA-Z0-9**

\\

Coincidencia con palabra exacta. Los caracteres validos son **a-zA-Z0-9**

EXPRESIÓN REGULARES BÁSICAS

\\{n\\}

n veces el caracter anterior

\\{n,\\}

Almenos n veces el caracter anterior

\\{n,m\\}

Entre n y m veces el caracter anterior

\\{BRE\\}

Memorización de una BRE(basic expresion regular)

\\1

EXPRESIONES REGULARES EXTENDIDAS

?

0,1 vez el carácter anterior o grupo anterior, igual a {0,1}

+

D 1 a n veces el caracter o grupo anterior. Igual a  {1,}

{n}

n veces el caracter anterior

{n,m}

Entre n y m veces

CARACTERES POSIX

Con -e podemos incluir varios filtros de de expresioenes

grep -e expresion1 -e expresion2 fichero

*   \-v: Muestra las lineas que no cumplen con la expresion regular
    
*   \-q: Modo silencioso Indica si la busqueda a sido exitosa o no como la variable $?
    
*   \-o: Imprime solo las coincidencias
    

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

apt-cache show apt-file > apt.txt

RENAME
------

Sirve para renombrar el nombre de los ficheros no el contenido de estos,

**rename /contenido\_cambiar/nuevo\_contenido/ fichero**

Permite el cambio a traves de expresiones regulares basicas o extendidas, muy util combinado con xargs, podemos listas los ficheros con un criterio, y con xargs pasarlos a rename

*   \-v –verbose: Muestra los archivos renombrados exitosamente
    
*   \-n –nono: No renombra, pero mostraria el resultado de como quedarían los archivos renombrados
    

SED
---

**sed \[-n\] acción \[fichero, …\]**

**sed \[-n\] -e acción1 \[-e accion2\] \[fichero, …\]**

**sed -f script-sed \[fichero…\]** 

Las **acciones** se ejecutan en cada línea del fichero. El resultado se mostrará por la salida estándar.

Sed no modificará el fichero origen a no ser que se emplee **\-i**

Sed muestra líneas coincidentes, **y además** todo el fichero

**\-n** únicamente mostrará líneas seleccionadas por la dirección de la acción

**\-E** permite expresiones regulares extendidas ERE

### SED-ACCIÓN

\[Dirección\[Dirección\]\]: Sobre que línea voy a aplicar el comando

Comando: Comando propio de sed que se ejecutará

Parametro: Parametro del comando

\[Dirección\[Dirección\]\] COMANDO parametro

### SED-DIRECCIÓN SIMPLE

Las direcciones simples se suelen utilizar para las primeras líneas o las últimas líneas de un archivos que suelen ser encabezados

Ninguna acción

Dirección simple 

Todas las líneas

n

Dirección simple

Linea n

$

Dirección simple

Ultima línea

/BRE/

Dirección simple

Lineas coincidente con la expresión regular

n1,n2**accion(p,d)**

Dirección multiple

Lineas de la n1 hasta la n2 ambas inclusive

/BRE1/,/BRE2/

Dirección múltiple

La a primera línea tratada será la coincidente con /BRE1/. El tratamiento continúa con el resto de líneas hasta la línea coincidente con /BRE2/, que será la última

\-n: Muestra solamente las líneas que coincida

### SED-COMANDOS

#### d (delete)

*   Elimina la primera línea de routertxt.txtcat routertxt.txt | sed ‘1d’ > fichero.txtsed ‘1d’ routertxt.txt > fichero.txt
    

*   Eliminar las diez primeras líneas del routertxt.txtsed ‘1,10d’ routertxt.txt > fichero.txt
    

*   Elimina líneas en blancosed ‘/^$/d’ routertxt.txt > textosinblancos.txt
    

#### p (print)

*   sed -n ‘$p’ sources.list
    
*   sed -n ‘1,2p’ sources.list
    
*   sed -n ‘/^deb.\*/p’ sources.list
    
*   sed -n ‘/^#/p’ sources.list
    

#### \= (Mostrar)

#### ! (negación)

*   sed -n /^#/!= sources.list
    

#### s (sustitución)

**s/antiguo/nuevo/\[g\]**

**\[g\]:**Opiconal, permite realizar la sustitución sobre toda la línea en caso de que haya varios coincidencias

router | sed “s/\[ \]\\{1,\\}/;/g” > routertxt.txt

sed ‘/-src/**s**/#//’ sources.list > sincomentarios.txt

#### w (write)

Escribe en el destino (fichero) las líneas coincidentes de un origen (otro fichero), los ficheros deben de estar creados previamente

**sed -n ‘/^#/w destino.txt’ origen.txt**

Escribe en los fichero comentarios y codigo del fichero sources.list

**sed -n -e ‘/^#/w comentarios’ -e ‘/^\[^#\]/w código’ sources.list**

#### a (anexar)

*   Anexa las líneas de texto, después de cada línea especificada
    
*   Se puede anexar al pie al fichero
    
    *   **sed -i ‘$a\\Pie’ sed1.txt** \=== echo ‘Pie’ >> sed1.txt
        

*   Inserción detrás de líneas en blanco
    
    *   **sed ‘/^$/a\\Línea se inserta después de una línea en blanco’ archivo.txt**
        

*   Anexa Name y descripción después de cada cadena entre \[\]
    
    *   **sed -E -i ‘/^\\\[\[a-z\]+\\\]/a\\Name:\\nDescripción:\\n’ sed3.txt**
        

#### i (insertar)

Similar al comando a (anexar)  pero en vez de la línea siguiente en la linea anterior

*   **sed -i ‘1i\\Encabezado’ sed1.txt** Añade una línea de encabezamiento
    
*   sed -i ‘/^.\*/i\\------seccion—-------\\n\\n’ sed1.txt 
    

#### c (reemplazar)

Reemplaza las líneas especificadas en la dirección por la o las líneas indicadas. Con s haremos cambio parcial sustituyendo una parte

*   sed -i ‘1c\\Es la nueva línea 1’ comentarios.txt Sustituye la primera línea
    

CUT
---

Cambia el formato de un fichero a formato de tabla, es decir por columnas

**cut -cColumnas \[fichero…\]**

*   Una columna es una posición de un carácter en una línea.
    
*   El primer carácter está en la columna 1, último en la columna 80
    

**cut -d\\; -F1,3,5-9 fichero.txt**

comando od permite ver el valor de cada byte en un fichero

*   \-k número de campo
    
    *   \-k1,3-bk1.3: Ordena por el tercer carácter del campo1
        
    *   bk1,2,3: Por 1º campo, después 3º caracter del 2º campo
        
*   \-d Ordenación de diccionario, el criterio son letras números y espacios
    
*   \-n ordenación numérica
    
*   \-b ignora espacios al principio del campo
    
*   \-f no diferencia entre mayusculas o minusculas
    
*   \-r orden inverso
    
*   \-tc nuevo delimitador de campo c
    

TR
--

No tiene entrada por defecto, debe ser redirigida por otro comando o tuveria

*   permite sustituir unos caracteres por otros
    

**tr \[opciones\] original destino**

AWK
---

Lenguaje de script, que se utiliza para el tratamiento en archivos de texto

**awk \[-F\] ‘{acción-awk}’ \[ arch1 … archN \]**

**awk \[-F\] -f script-awk \[ archi1…archN \]**

Recibe una relación de argumentos a tratar, si no recibe argumentos, trabaja con la entrada estandard

### AWK, VARIABLES

$0

Valor de registro actual, (linea actual)

$1 $2 $3

Referencia al campo en la posición indicada

NF

Número de campos que tiene el registro actual, (numero de palabras de la fila) 

$NF

(Ultimo campo)

NR

Indice de registro actual, si estamos en el registro 3 NR será 3

FILENAME

### AWK, ACCIÓN-AWK PRINT

Las acciones o instrucciones deben colocarse entre llaves **{print}**

Muestra los campos 1 y 2, variables $1 y $2 del fichero o flujo introducido

**ps aux > awk ‘{print $1,$2}’**

**awk ‘{print $1,$2}’ procesos.txt**

print tambien acepta cadenas como argumento

**ps aux | awk ‘{print “Usuario: ”$1,”PID: ”$2}’**

En los archivos como /etc/shadow tienen un campo delimitardor de **:** a diferencia de archivos normales que cuentan con espacios o tabulaciones, debemos de indicarle a awk cual es el delimitador de campo, para ello utilizamos la opción **\-F “:”** 

cat /etc/shadow | awk -F “:” ‘{print “Usuario: ” $1”Shell: ”$7}’

sudo cat /etc/passwd | awk -F ":" '{print "Registro:"NR "\\tUsuario: "$1 "\\t\\t\\tShell: "$7}'

awk utiliza expresiones regulares extendidas que deben estar entre **/**

*   **awk -F “:” ‘/debian|root/ {print $0}’ passwd.txt**
    

Muestra las lineas que tengan debian o root

Correspondencia de un campo con la expresión regular mediante operador ~

*   **sudo cat /etc/passwd | awk -F ":" '$7~/bash/{print $0}'**
    

El operador **!** niega la expresión regular 

*   **sudo cat /etc/passwd | awk -F ":" '!~/bash/{print $0}'**
    

SISTEMAS DE FICHEROS/ARCHIVOS
-----------------------------

*   Bloque: Unidad mínima de almacenamiento con la que trabajan los sistemas de ficheros. En ext4 por defecto el 512 Bytes, es decir cada fichero va a tener si o si ocupado 512 Bytes minimos en el disco
    

### Supuesto practico1

*   Tamaño del fichero 1 byte , tamaño del bloque 4096 bytes, se estarán desperdiciando 4095
    

### Supuesto practic o2

*   Disco con 128.000 bloques de 4096 bytes
    
*   Tamaño total será 500 Mbytes
    
*   Supongamos  128.000 ficheros de 400 bytes
    
*   128.000\*400=48,83 Mbytes
    
*   **Disco lleno unicamente con 48,84 Mbytes**
    
*   Se desperdician 451,17 Mbytes
    

Dependiendo si vamos a trabajar para uso general o no sabemos cuánto vamos a utilizar exactamente, es mejor utilizar un tamaño de término medio, si sabemos que vamos a trabajar con ficheros que van a ocupar poco espacio es mejor ajustar el tamaño de los bloques para que estos sean también pequeños 

HERRAMIENTAS SISTEMAS DE FICHEROS
---------------------------------

Algunos comandos calculan el tamaño de los ficheros en bloques: **du, df o find**

du -h; du

dj -h; df -Th Muestra también tipo fs

df -i Modo inodo, muestra indoso totales usados libres

find -size +4b ficheros de más de 4 bloques 

El tamaño de los bloques históricamente era de 512 o 1024 bytes

### TABLA DE INODOS

Es una estructura de datos donde se almacenan los inodos utilizados donde estos indican donde se encuentrar quien lo hizo, fecha de creacion y modificación, permisos …

El contenido el cual infoforma un inodo es el siguiente (meta-información)

*   Tamaño
    
*   Identificador del periferico que lo contiene
    
*   Su propietario
    
*   Su grupo
    
*   Su número de inodo
    
*   Derechos de acceso
    
*   Fecha de ultima modificación del indo
    
*   Fecha de uĺtima modificaciḉon del contenido
    
*   Fecha de ultimo acceso 
    
*   Contador de hardlinks
    
*   Campos de direcciones de bloques. Contenido propiamente dicho del fichero
    

DIRECCIONES INDIRECCIONES DE INODOS
-----------------------------------

El inodo contiene campos de direcciones de bloques

*   Direcciones que apuntan directamente a los bloques
    
*   Direcciones que apuntan a bloques(estructuras de datos) que contienen otros campos de direcciones 
    
*   Tres campos de indireccion
    
    *   Indireccioón simpl
        
    *   Indireccion doble
        
    *   Indireccion triple
        

Ejemplo para sistema de fichero ext2

Diez campos que apuntan a un bloque de datos

Indireccioón simple apunta a 256 direcciones de bloques de datos

Indireccion doble apunta direcciones las cuales apuntan cada una a otras 256 direcciones de bloques de bloques de datos

Indireccion tripole, 256 direcciones las cuales apuntan cada una de ellas a toras 256 direcciones que a su vez apuntan a 256 direcciones de bloques de datos

### dumpe2fs

### ext3grep

Los catálogos, son los directorios o carpetas, permiten organizar el disco creado una jerarquía 

CREACIÓN DE UN SISTEMA DE FICHEROS
----------------------------------

mkfs(make filesystem)

mkfs -t tipo opciones perifericos

Donde tipo puede ser ext2, ext3, ext4, vfat …

mkfs -t ext2 /dev/sdc ó mkfs.ext2 /dev/sdc1

mkfs -t ext2 -b 2048 -m 0 -l “Datos” /dev/sdc1

UEFI SHELL
==========

help: muestra la ayuda de comando

*   \-d: Pagina la ayuda
    

bcfg: Podemos cambiar el orden de arranque de la EFI

map: Mapea los dispositivos

Nombre dispositivo mapeado: Para acceder a un dispositivos especifico

cd: Como debian

ls: Como debian

BINARIOS

los .efi son ejecutables

*   grubx64.efi: Binario que me vuelve al grub
    
*   fbx64.efi:
    

SWAP 
=====

La memoria swap es la utilización de memoria física como ampliación de la memoria ram en caso de que esta esté toda utilizada.

Tamaño recomendados swap:

*   RAM < 512MBswap doble que la ram
    
*   RAM 1GB - 4GB swap del mismo tamaño que la RAM
    
*   RAM > 4GBswap de 4GB
    

La swap es necesaria si queremos habilitar la hibernación del equipo. La info cargada en memoria es cargada en swap al apagar el sistema cesando toda actividad en el equipo. En el siguiente incio la información será restaurada

Se puede indicar en qué momento de se activa el swap, esto es gestionado por el kernel.

**/proc/sys/vm/swappiness** este archivo conetien el valor a restar del 100 % de la memoria para la activación de la swap EJ: en el fichero contiene el valor 60 100-60 = 40% la swap se activara al momente de que la ram este al 40%

Para hacerlo persistente editamos el fichero **/etc/sysctl.conf** este fichero contiene configuraciones que interaccionan con el kernel, y añadimos el valor **vm.swappiness=VALOR**

**mkswap** /dev/???? -L label

Se puede crear un fichero actuando como dispositivo de bloque simulando la swap, este fichero es menos efectivo que la propia partición swap

dd if=/dev/zero of/swap bs=1024 count 65536

mkswap /swap

chmod 600 /swap

swapon -v /swap

free | grep swap

/etc/fstab

/swapswapswapdefaults00

ZRAM

Utiliza part de la memoria RAM

RAM es más rápida y eficiente que un disco, pratición o un fichero 

La memoria utilizada, estará en modo comprimido es por ello que necesitamos de procesador

apt install zram-tools

Fichero de configuración: /etc/default/zramswap

*   Grado de compresión
    
    *   speed:lz4 >zstd>lz0
        
    *   compression:zstd >lzo >lz4
        
    *   ALGO=lz4
        

No es compatible utilizar size y percent al mismo tiempo, además de habilitar un servicio

Comprobamos que el servicio esta activo,

systemctl muestra todos los servicios y actua como un less

Despues systemctl status nombre del servicio

swapon -s para ver el estado 

si queremos evitar que se monte la partición swap y utilizar la zramswap creda debemos de comentar la linea de la partición swapt /etc/fstab y en el proximo arranque ya no estará en uso

JOURNALCTL
==========

Ver los archivos logs del sistema

journalctl -u systemd-journald.service -f

*   \-u indicamos el servicio
    
*   \-f
    

GRUB EFI INITRAMFS
==================

*   fbx64.efi: Ejecutable para acceder al firmware (EFI/BIOS)
    
*   grubx64: Ejecutable para el grub firmado por debian/linux
    
*   shimx64.efi: Ejecutable para el grub firmado por microsoft
    
*   mmx64.efi: Nos dirije al gestor de firma de los kernel de arranque
    

El gestor de arranque a la hora de ejecutar un sistema utiliza principalmente 2 cosas

*   Kernel: Todo lo fundamental para el arranque. Si el kernel está mal necesitas es más difícil de reparar(**kernel panic**). Hay un shell con comandos específicos para el kernel
    
*   Initramfs: Contiene módulos de arranque del kernel, cosas no fundamentales pero que complementa al kernel con el objetivo de arrancar el sistema. Si el initramfs esta mal
    
    *   initrd> Esta shell cuenta con funciones  para poder 
        

El grub cuenta con su propia shell

*   ls: vemos los dispositivos de bloque y el particionado
    
    *   ls (hd0,gpt1)/ Vemos el contenido de la partición
        
*   insmod linux: Importamos módulos de arranque, 
    
*   linux (hd0,gpt3)/vmlinuzXXXXX root=/dev/vda3: Importamos el kernel y le indicamos donde esta el sistema de ficheros, necesario identificar el tipo de dispositivos que se utiliza 
    
*   initdr (hd0,gpt3)/intramfsXXXXX: Indicamos el initramfs, misma versión que el kernel
    
*   boot: Arrancamos con los cambios hechos, puenteando el grub
    

Cuando llegamos al grub e seleccionamos un kernel de arranque y no arranca pero con otro si, es posible que el kernel o el initramfs puede que esten dañados, para solucionarlo:

*   initramfs: Utilizando update-initramfs -u version podemos actualizar el initramfs
    

PROCESOS
========

PCB: Bloque de control de procesos, es una variable que cuenta con varios campos que almacena como puede ser el ID del proceso, o el PID.

El sistema trabaja con los identificadores de procesos y no con nombres.

Para ver los procesos podemos utilizar **ps aux,** el primer proceso y el padre de todos es el proceso init

con la variable **$$** puedo ver el proceso de la bash actual en la que me encuentro

**Ctrl + z** envia a dormir (pausa en segundo plano) un proceso y con **Ctrl + c** lo elimino

Otra forma para enviarlo a segundo plano es utilizar **&** para ello

**comando &**

Con el comando **fg(foreground)** podemos traer los procesos de segundo plano a primer plano ej

**fg %numero\_de\_job**

El comando pidof, identifica los procesos de un determinado comando

SESIONES
========

Las sesiones son dependientes de las TTY  donde estas tienen una configuración, variables permisos usuarios… definidos anteriormente, una sesión puede tener varias ventanas asociadas a esta.

Los procesos generados en la sesión siguen en ejecución aun después de salir/ esta

Las regiones de una sesión es parecido a dividir la pantalla de terminator y estas regiones tienen ventanas comunes

Utilizando screen puedo crear sesiones.

*   **screen -S nombre**
    
*   **screen -ls (ver sesiones)**
    

Dentro de las sesiones utilizando la combinación de **Ctrl + a**  y a continuación **Shift + “** muestro las ventanas de las sesiones

Si la sesión es attached indica que estamos en esa sesión, para salir de la sesión utilizamos **Ctrl + a y despues pulsamos d (detached)** y para reconectarmos:

*   **screen -r \[nombre\_session\]**
    

Con **Ctrl + a y despues pulsamos A** renombramos la ventana

**Ctrl + a y despues pulsamos c** nueva ventana

**Ctrl + a y despues pulsamos S** nueva region de la sesion

Con **Ctrl + a pulsmos |** se crea una region verticalmente

Con **CTRL + a y pulsamos k borramos la ventana y pulsando X la region**

**CTRL + a y pulsamos : podemos ejecutar ciertos comandos para crear sesiones multiusuario**

**multiuser on**

**useradd usuario**

**aclchg usuario + permisos\[r/w\] nombre\_ventana “#” <- todas las ventanas**

**screen -x usuario/IDsesion**

**HAY QUE DARLES PERMISOS** 

**chmod u+s /usr/bin/screen**

**chmod 755 /run/screen**

SCRIPT
======

#!/ruta/intérprete

El #! se denomina “_seban_” para muchos scripts es necesario pero hay algunos como el .bashrc en el que no son necesarios

Los intérpretes pueden ser bash sh php python … lo más estándar es _**#!/usr/bin/env nombre\_interprete**_ 

Para crear un script partimos de un fichero normal y corriente que tiene que tener el permiso de ejecución en función del metodo de ejecución que utilicemos y podemos editarlo con cualquier procesador o editor de texto como puede ser el Visual Studio o el editor por defecto del sistema

Para ejecutar un script podemos utilizar varios métodos

*   **/ruta/absoluta o relativa /script**
    
*   **intérprete /ruta/script**
    
*   **source /ruta/script**
    
*   **. /ruta/script**
    

Con el método de **intérprete /ruta/script** no es necesario que el archivo tenga permisos de ejecución y este se va a ejecutar en una shell hija y se puede dar el caso que las variables que se tengan en la shell principal, no se encuentren en la shell hija o no contengan el mismo valor

Con el método **/ruta/absoluta o relativa /script** el fichero si necesita permisos de ejecución y se ejecutará en una shell hija.

El sistema busca los binarios en ciertas rutas que se pueden ver en la variable **$PATH** para modificarla.

Si utilizamos **export** podemos exportar variables de la shell padre a la shell hija y modificarla a nuestro antojo. Hay que tener en cuenta que las variables cambian por lo que tenemos que tener el valor de la original en caso de querer restaurarla:

#!/bin/bash

export oldpath=$(echo $PATH) Con esto guardamos el valor original

export $PATH=$PATH:/nueva/ruta Añadimos una ruta

export $PATH=oldpath Volvemos a poner el valor original

La ejecución con el comando **source** no necesita de permisos de ejecución y se ejecuta en la shell actual 

La ejecución con el comando **.** _**ruta\_absoluta\_o\_relativa**_ tampoco necesita de permiso de ejecución y se ejecuta en la shell actual

Para comentar los scripts hay varias formas:

*   Utilizando **\#** comenta una sola línea
    
*   Utilizando **<<< NOMBRE\_ETIQUETA** _**comentario**_ **NOMBRE\_ETIQUETA** 
    

**LAS SHELLS HIJAS NO SON IGUALES QUE LAS SUBSHELL**

UNA SHELL HIJA NO TIENE QUE RECONOCER LAS VARIABLES DEL PADRE, PERO UNA SUBSHELL SI RECONOCE LAS VARIABLES DEL PADRE

PASO DE ARGUMENTOS AL SCRIPT
----------------------------

Los argumentos se pasan a través de las variables posicionales

*   $0 Nombre del script
    
*   $1, $2, $3 … $9 los nueve primeros argumentos
    
*   ${10}, {11}...
    
*   $# número de argumentos pasados al script
    
*   $@, $\* Todos los argumentos, empezando por $1
    
*   $$ PID del shell que interpreta el script
    
*   $! PID del último comando ejecutado en segundo plano desde el script
    
*   $? código de estado de ejecución del último comando
    

A las funciones tambien se le pueden pasar estos argumentos hay que saber diferernciar entre los argumentos a funciones, script, o el comando set

El comando **shift** permite desplazar argumentos a **n** posiciones a la izquierda ej:

    $1     $2

**script.sh arg1 arg2**

shift 1

                  **$1**

**script.sh arg2**

La funcionalidad es recorrer los argumentos de forma secuencial y pudiendo hacer referencia a una unica variable posicional casi siempre en vez de hacer referencia a $8 con shift podemos indicarle que se desplace los argumentos 7 veces a la izquierda de modo que al querer hacer referencia a $8 hacemos referencia a $1

ENTRADA DE DATOS MANUALMENTE AL SCRIPT
--------------------------------------

Para introducir datos manualmente utilizamos el comando **read** y la información se almacena en una variable

**read variable\_dato**

read var1

read var1 var2

*   **\-p “OUTPUT”** Con esta opción podemos indicarle un texto que será visible para introducir los datos, como si fuera un input de python
    

*   \-**s:** Modo silencioso, no muestra el input que se solicita
    
*   **\-n num\_caracteres:** Indicamos el numero especifico de caracteres
    
*   **\-t segundos:** Indicamos el tiempo de espera máximo en segundos
    

ESTRUCTURA CONDICIONAL IF
-------------------------

Hay varias formas de especificar una condición, ambas funcionan por igual y son comandos internos

*   **test ó \[ \]**
    
*   **\[\[ \]\]**
    

sintaxis:

*   test expresion ó \[ expresión \]
    

### Condiciones sobre cadenas de texto

Igualdad

*   \[ “$a”=”$b” \]
    
*   \[ “$a”==”$b” \]
    

Desigualdad

*   \[ “$a”!=”$b” \]
    

\[ “$a” \\< “$b” \]                         Orden alfabético

\[ “$a” \\> “$b” \]                         Orden alfabético inverso

\[ -z “$a” \]ó test -z “$a”             variable es vacía, cierto

\[ -n “$a” \]ó test -n “$a”             contiene algo, cierto

### Condiciones sobre numericos

\[ $a -eq $b \]ó test $a -eq $bIgualdad

\[ $a -ne $b \]ótest $a -ne $bDesigualdad

\[ $a -gt $b \]    ó test $a -gt $bMayor que

\[ $a -lt $b \]    ótest $a -lt $bMenor que

\[ $a -ge $b \]ó test $a -ge $bMayor o igual que

\[ $a -le $b \]    ótest $a -le $bMenor o igual que

### Condiciones sobre ficheros

\[ -e nombre fichero \] existencia

\[ -f nombre fichero \] true si es fichero ordinario

\[ -s nombre fichero \] true si es fichero no vacío (0 bytes)

\[ -d nombre fichero \] true si es directorio

\[ -b nombre fichero \] true si es dispositivo de bloques

\[ -c nombre fichero \] true si es dispositivo de caracteres

\[ -r nombre fichero \] true si tiene permiso de lectura

\[ -x nombre fichero \] true si tiene permiso de ejecución

\[ -w nombre fichero \] true si tiene permiso de escritura

test -e nombre fichero  true si existencia

test -f nombre fichero true si es fichero ordinario

test -s nombre fichero true si  es fichero no vacío

test -d nombre fichero  true si es directorio

test -b nombre fichero  true si  es dispositivo de bloques

test -c nombre fichero  true si  es dispositivo de caracteres

test -L nombre fichero  true si  es enlace simbólico

test -r nombre fichero true si tiene permiso de lectura

test -x nombre fichero  true si  tiene permiso de ejecución

test -w nombre fichero true si  tiene permiso de escritura

### OPERADORES LÓGICOS

\[ “EXPR1”-a”expr2” \] AND entre expr1 y expr2

\[ “expr1”-o”expr2” \] OR entre expr1 y expr2

\[ !expr1 \] NOT expr1

### AGRUPACIONES

Permite priorizar los operadores utilizando () y estos hay que escaparlos

En el ejemplo de abajo primero comprueba la existencia **\-e** del $dir1 o **\-o** la existencia **\-e** $dir2 despues comprueba si $fich1 tiene permiso de escritura **\-w** y se tiene concatena ambas estructuras con **\-a** que es el operador basico **and**

\[ -w $fich1 -a \\(-e $dir1 -o -e $dir2\\) \]

### COMANDO \[\[ \]\]

Versión avanzada de test o \[\]

Los operadores lógicos and y or cambian a **&&** y **||** 

### COMPARACIÓN DE CADENAS MEDIANTE PATRON

Podemos comparar con expresiones regulares propias, para ello tenemos que empezar la comparación con una viguerilla  **~**

###  ESTRUCTURA IF

**1º**

**IF** COMANDO

**THEN**

COMANDOS

**FI**

**—--------------------------------**

**2º**

**IF** COMANDO

**THEN**

COMANDOS

**ELSE**

COMANDOS

**FI**

**—--------------------------**

**3º**

**IF** COMANDO

**THEN**

COMANDOS

**ELIF** COMANDO2

**THEN**

COMANDOS

**ELSE**

COMANDOS

**FI**

Hay otra opción, cuando el comando es uno podemos utilizar 

**comando1 && comando2** si el comando 1 devuelve codigo 0 se ejecuta el comando 2 y queda de mejor forma en el codigo

Tambien se puede utiliza la siguiente sintaxis:

**if** comando1**; then**

comando2

**fi**

LIBRERAS
--------

Conjunto de funciónes que se pueden implementar en los scripts para la reutilización de codigo. Mediante **source** o **.** se invoca la librería:

*   libreria=/home/debian
    
*   **source $libreria/funciones**
    
*   _**nombre\_funcion\_libreria**_
    

Las funciones tambien se pueden utilizar en una línea

*   **function** _**nombre { comandos }**_
    
*   _**function nombre {**_
    
    *   _**comandos**_
        
    *   _**}**_
        

Podemos editar las funciones escritas en la propia terminal con **control + x + control + e**

getops
------

BUCLES
------

**for “**variable**”  in “**recorrido**”;**

  **do**

  comandos;

  **done**

**while** condición**;**

**do**

  comandos

**;done**

SENTENCIA CASE
--------------

Se utiliza principalmente para realizar múltiples comparaciones con una variable o expresión y ejecutar diferentes acciones segun el resultado de estas comparaciones, se suele utilizar en la creación de menús

**CASE** variable **IN**

**patron)**

**bloque1**

**;;**

**patron)**

**bloque2**

**;;**

**patron)**

**bloque3**

**;;**

**\*)**_indica bloque por defecto en caso de que ningun patron se cumpla_

**bloque por defecto**

**;;**

**esac**

case “uno” in

u)

echo “u”

;;

u?o)

echo “u?o”

;;

u\*)

echo “u\*”

;;

\*)

echo “ninguno”

;;

esac

Ficheros
--------

La lectura de un fichero se realiza mediante read

read lee de la entrada estandar,

Cuando lee una linea devuelve verdadero

Cuando llega al final del fichero devuelve falso

while read linea;

do

(( contador ++ ))

echo “Linea numero $contador contenido: $linea”

;done

Otra opción para leer un fichero es:

**cat fichero.txt | while read primera segunda tercera cuarta; do**    

**“echo el contenido de las variables son: $primera $segunda $tercera $cuarta” >>origen.txt**

**;done**

Origen.txt va a ir almacenando el contenido de las variables

DEPURACIÓN DE SCRIPTS
---------------------

Imprime cada una de las instrucciones, bhay varias opciones:

*   Utilizar -x en la cabecera del scritp**#!/bin/env -S bash -x**
    
*   En la invocación**bash -x script.sh**
    
*    Utilizando el comando set dentro del script, este comando depura el fragmento de codigo que se encuentra entre **set -x** y **set +x**
    

Podemos utilizar -u para indicar un error en caso de que haya una variable no definida

**bash -u scrip.sh || set -u set +u**

**bash -n** no ejecuta el script sino que simplemente chequea la sintaxis

**bash -v** devuelve el error y la linea en la que se encuentra

El comando **shellcheck** analiza el codigo y te recomienda buenas prácticas

DIALOG
======

 dialog --inputbox "Título" 20 10

USUARIO ESPECIALES
==================

con chmod 0=fichero eliminamos todos los permisos

Máscara de permisos:

WINDOWS
=======

**wpeutil** sirve para ejecutar ciertos comandos en el entorno de preisntalación

Las rutas de comandos estan en **C:\\Windows\\System32**

**bcdboot c:\\Windows /s f: /f UEFI**

Para comprobar que unn sistema windows esta funcionano en **UEFI** O **BIOS** podemos mirar la información de sistema:

Para elevar privilegios en el cmd de windows para ser administradores utilizamos el comando

*   **runas**
    
    *   **/?:** Muestra la ayuda
        

Si tenemos la particion de recuperación creada, hay una ruta **C:\\Windows\\system32\\recovery** 

El contenido de este directorio esta oculto , los podemos visualizar con dir y una opcion

En este directorio hay un archivo **winrec.wim** indica que la particion de recuperación no esta activada

Con **reagentc /info** podemos verificar si la partición esta activada

reagentc /disable /enable se puede activar o desactivar

Podemos entrar en modo recuperación sin usar una ISO siempre que tengamos el sistema operativo funcional

*   **shift + reiniciar**
    
*   Configuración de windows>actualización y seguridad> recuperacion
    
*   **shutdown -o -r -t 10**
    
    *   **\-r reboot**
        
    *   **\-t tiempo**
        
    *   **\-o va al menu de arranque avanzado**
        

Si pulsamos en configuración de inicio y después en reiniciar, a posterior nos aparecera un menu de arranque para seleccionar el modo seguro

bcdedit editor de configuración de arranque
-------------------------------------------

Comando que permite modificar el gestor de arranque de windows

**bcdedit /?**

El archivo original que se modifica con bcdedit se encuentra **F:\\EFI\\Microsoft\\Boot\\BCD**

Este archivo tambien es el generado o modificado por **bcdboot**

Si hay algun problema con el sistema utlizamoso  **sfc /scannow** en caso de que este comando no funcione utilizamos el siguiente:

*   **dism /online /Cleanup-image /checkhealt** /online si el sistema está arrancado 
    
*   **dism /image:d: /cleanup-image /restorehealth /sourtce:e:\\windows**
    

POWERSHELL
----------

Todo comando de powershell está compuesto por un verbo y un nombre en singular

Para actualizar la ayuda de un comando of funcion hay que actualizar el modulo para saber el modulo del comando puedo utilizar get-command nombre\_comando

La ayuda de la powershell 7 (nueva version de powershell) la ayuda esta en la nube

*   **winget**: Gestor de paquetes desde linea de comandos de windows, no tan avanzado como los gestor de paquetes de gnu-linux
    
*   **measure-object:** Cuenta los objetos de salida de los comandos